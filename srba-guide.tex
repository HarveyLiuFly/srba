\documentclass[a4paper,11pt]{article}
  
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{array}
\usepackage{float}
\usepackage{subfigure}
\usepackage{color}
\usepackage{listings}
\usepackage[utf8x]{inputenc}
\usepackage{hyperref}
\usepackage{rotating}

\usepackage{amsfonts}  % For \mathbb

% Read MRPT version:
\newread\file
\openin\file=../../version_prefix.txt
\read\file to\MRPTVERSION % Reads a line of the file 
\closein\file

% Title Page
\title{User guide for \texttt{libmrpt-srba}: A generic C++ framework for Relative Bundle Adjustment (RBA)}
\author{Jose-Luis Blanco-Claraco \\ joseluisblancoc@gmail.com \\ \texttt{http://www.mrpt.org/} }
\date{MRPT version: \MRPTVERSION \\ Document build: \today }

% C++ listings settings
\lstset{ %
language=C++,                % choose the language of the code
basicstyle=\scriptsize,       % the size of the fonts that are used for the code
numbers=none,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
commentstyle=\color{blue},
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

\begin{document}
\maketitle


\vfill

\begin{scriptsize}
\begin{center}
\includegraphics[width=3cm]{imgs/by-nc-nd-eu.pdf}
\\
This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License.
\end{center}
\end{scriptsize}

\vspace{1cm}

\newpage

\textbf{Revision history:}
\begin{itemize}
 \item Feb 2013: First version. Released along MRPT 1.0.0.
\end{itemize}

\vfill


\begin{small}
In case you want to cite this guide in your academic publications, here is a BibTeX entry: 

\begin{verbatim}
@MISC{libmrpt-srba-guide,
  author = {Jose-Luis Blanco-Claraco},
  title = {{User guide for \texttt{libmrpt-srba}: A generic 
      C++ framework for Relative Bundle Adjustment (RBA)}},
  howpublished = {http://www.mrpt.org/srba},
  year = {2013}
} 
\end{verbatim} 

\end{small}

\vspace{1cm}

\newpage
\tableofcontents
\newpage

\section{Introduction}

Bundle adjustment (BA) is the name given to one solution to visual SLAM based on maximum-likelihood estimation (MLE) 
over the space of map features and camera poses. However, it is by no way limited to visual maps, since the same 
optimization techniques employed in BA are also applicable to maps of pose constraints (graph-SLAM) and to many other 
kind of feature maps, not necessarily involving visual information.

The framework of \emph{Relative Bundle Adjustment (RBA)} was introduced in a series of works by Gabe Sibley and 
colleagues in \cite{sibley2009rba,sibley2009adaptive}. 

\emph{Sparser RBA (SRBA)} is the name of the generic and extensible framework for RBA, implemented in 
the C++ library \texttt{mrpt-srba}. It features the introduction of 
a \emph{constant-time algorithm} for maintaining problem graphs with arbitrary topologies 
(as presented in \cite{blanco2013srba}), as well as a generic design which allows turning RBA 
into \emph{relative Graph-SLAM} (i.e. networks of relative pose constraints whose solution are also relative poses).

\section{Library installation}

\texttt{mrpt-srba} is one of the libraries of the Mobile Robot Programming Toolkit (MRPT). 
It is header-only and makes \emph{intensive} use of templates and design patterns for the sake of customization, 
flexibility and extensibility. 

Note however that it depends on other non-header-only libraries\footnote{The link-time dependencies are: \texttt{mrpt-base} 
for geometry, math auxiliary classes, serialization,... and \texttt{mrpt-opengl} for generating 3D representations of 
the RBA problems. Despite its name, the latter library can be built for platforms without any 
functional \texttt{OpenGL} implementation, though it is recommended to always visualize the results for getting a better 
insight of what is going on in your programs. The header-only library \texttt{Eigen} \cite{eigenweb} is also a mandatory dependency, but 
an embedded version is shipped with \texttt{mrpt-base} in case the user does not have it installed.}, 
so in practice before using \texttt{mrpt-srba} in your program you need
both (i) access to headers (\texttt{.h} files) and (ii) binary libraries to link against them. 

In Ubuntu, installing the package \texttt{libmrpt-dev} (version 1.0.0 or newer) is the easiest way to have 
everything ready to start coding your own programs. You can also install \texttt{mrpt-apps} for the application \texttt{srba-slam} 
and a set of sample datasets (see \S\ref{sect:srba_slam_app}).

If your official repository has an older version of the package, use this PPA repository instead:

\begin{lstlisting}
 sudo add-apt-repository ppa:joseluisblancoc/mrpt
 sudo apt-get update
 sudo apt-get install libmrpt-dev mrpt-apps
\end{lstlisting}

Binary packages for Windows are also available online\footnote{\href{http://www.mrpt.org/download}{http://www.mrpt.org/download}}.
If you prefer to build MRPT from sources, please visit the official web\footnote{\href{http://www.mrpt.org/}{http://www.mrpt.org/}} 
for detailed instructions.


\section{RBA primer}
\label{sect:rba_primer}

This manual will not explain the mathematical details of how RBA is modeled and solved -- please, refer to cited papers.
Though, it is mandatory to clearly establish which \textbf{entities} define an RBA problem before discussing the library API.

An example such that the one in Fig.~\ref{fig:rba.entities} will help introducing the different elements.
The illustration depicts many elements, some of which are \emph{known} data, others are the problem \emph{unknowns}. 
The goal of RBA is to recover a \emph{maximum-likelihood estimation (MLE)} of those unknowns. Optionally, the covariances and 
cross-covariances between estimated variables can be also evaluated.

\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{imgs/srba_toy_problem.pdf} 
\caption{A toy RBA problem.}
\label{fig:rba.entities}
\end{figure}

We find the following entities in \texttt{mrpt-srba} (refer to Fig.~\ref{fig:rba.entities}):

\begin{itemize}
\item{\textbf{Keyframes}: A keyframe (KF), as each $KF_i$ in the figure, represents the \emph{pose} of the robot (or the 
camera or whatever) at one  particular instant of time. In RBA we will never work with the absolute coordinates of any of 
these KFs. This is completely different than ``common'' Bundle Adjustment, where these poses are the unknowns to 
estimate.
}
\item{\textbf{Keyframe-to-keyframe edges}: An edge $k2k_i^j$ represents the relative pose of $KF_i$ with respect to 
$KF_j$. Notice that ``inverse poses'' (i.e. in the inverse order than one would expect from the edge direction) are 
stored for efficiency\footnote{In RBA we may need to chain sequences of relative poses, and the direction will often 
be from newer KFs towards older KFs, hence if we store inverse poses we save the computational burden of inverting them 
over and over again.}. These edges are always treated as \emph{unknowns} to be estimated from observation data.
They can be parameterized in different ways (see \S\ref{sec:k2k_types}), but in practice it will be enough to work 
with SE(2) or SE(3) poses.
}
\item{\textbf{Landmarks}: A landmark (LM) is any entity which can be observed from different locations. Typically a 2D 
or 3D point in space, but could be a line, segment, plane or any user-defined entity. They are represented in 
the Fig.~\ref{fig:rba.entities} as stars named $LM_i$. The concept of absolute coordinates of a LM 
does not exist in RBA.
}
\item{\textbf{Relative position and "base keyframe" of a LM}: Each LM is associated to exactly one KF, its {base KF}, with 
respect to which the LM has a \emph{relative position}. This relative position can be either ``known'' (``\emph{fixed}'' 
in the C++ API) or ``unknown'', in which case it is also estimated during the problem optimization. There exist several 
possible ways of parameterizing relative positions, as discussed in \S\ref{sec:k2f_types}. These relative positions are 
represented in the figure as thick edges with a middle circle mark.
}
\item{\textbf{Observations}: An observation $z^{i,j}_k$ stands for any piece of sensory data which \emph{is related}, 
somehow, with the position of the $i-th$ LM, whose base KF is $j$, as seen from the observing KF $k$. They are 
depicted as dashed lines in the figure above. Rank-deficient observations, like those from monocular cameras, are 
acceptable but two or more observations may be required before being able to estimate the relative position of the 
observed LM.
}
\end{itemize}

\newpage


\section{Programmer's first steps}
\label{sect:program_first}

The central class in \texttt{libmrpt-srba} is the template \texttt{RbaEngine<>}, which 
adopts a ``policy-based design'' \cite{andrei2001modern}:

\begin{lstlisting}
template <
	class KF2KF_POSE_TYPE,
	class LM_TYPE,
	class OBS_TYPE, 
	class RBA_OPTIONS = RBA_OPTIONS_DEFAULT>
class RbaEngine;
\end{lstlisting}

This means that by setting each of the \emph{template arguments} we literally control the process 
of code generation to address one particular instance of a RBA problem. 
Since all this happens at \emph{compile time}, the compiler produces optimized code for 
the problem at hand (e.g. SSE2 code for multiplying matrices of a particular size), 
avoids code bifurcations, etc.

Due to the combinatorial nature of all the possibilities, 
detailed in \S\ref{sect:rba_configs}--\ref{sect:rba_options}, one template class 
can generate specialized code for dozens of concrete problems.


\subsection{The simplest program}

The following code illustrates the declaration of an RBA problem for 3D point landmarks, 
with SE(3) relative poses for keyframes and 3D range-bearing observations. 
Only two keyframes are defined, which means that after introducing the second one
there will be only one k2k edge (an unknown), which will be estimated by the least-squares 
optimizer along the relative positions of all landmarks.

\begin{lstlisting}
#include <mrpt/srba.h>

using namespace mrpt::srba;
using namespace std;

typedef RbaEngine<
	kf2kf_poses::SE3,       // Parameterization  KF-to-KF poses
	landmarks::Euclidean3D, // Parameterization of landmark positions    
	observations::RangeBearing_3D // Type of observations
	>
	my_srba_t;

int main(int argc, char**argv)
{
	my_srba_t rba;  //  Create an empty RBA problem
	
	// Define observations of KF #0:
	// ----------------------------------------------
	my_srba_t::new_kf_observations_t  list_obs;
	my_srba_t::new_kf_observation_t   obs_field;
	obs_field.is_fixed = false; // Landmarks have unknown relative 
	                            // positions (i.e. are unknowns )
	obs_field.is_unknown_with_init_val = false; // We don't have 
       // any guess on the initial LM position (will invoke the 
       // inverse sensor model)

	// For each observation:
	for (...) {
		obs_field.obs.feat_id = ...; // The landmark ID
		obs_field.obs.obs_data.range = ...;
		obs_field.obs.obs_data.yaw   = ...;
		obs_field.obs.obs_data.pitch = ...;
		list_obs.push_back( obs_field );
	}

	//  This is the main API entry point: Define KF #0
	my_srba_t::TNewKeyFrameInfo new_kf_info; // Placeholder of out info.
	rba.define_new_keyframe(
		list_obs,      // Input observations for the new KF
		new_kf_info,   // Output info
		true           // Run optimization of the local area
		);

	// Define observations of KF #1:
	// ----------------------------------------------
	list_obs.clear();
	// For each observation:
	for (...) {
		obs_field.obs.feat_id = ...; // The landmark ID
		obs_field.obs.obs_data.range = ...;
		obs_field.obs.obs_data.yaw   = ...;
		obs_field.obs.obs_data.pitch = ...;
		list_obs.push_back( obs_field );
	}

	//  This is the main API entry point: Define KF #1
	rba.define_new_keyframe(
		list_obs,      // Input observations for the new KF
		new_kf_info,   // Output info
		true           // Run optimization of the local area
		);

	cout << "Created KF #" << new_kf_info.kf_id 
	 << " | # kf-to-kf edges created:" <<  
	 new_kf_info.created_edge_ids.size() << endl <<
	 "Optimization error: " << 
	 new_kf_info.optimize_results.total_sqr_error_init << 
	 " -> " << 
	 new_kf_info.optimize_results.total_sqr_error_final << endl;

	// Save RBA graph as Graphviz file:
	rba.save_graph_as_dot("graph.dot", true /* LMs=save */);

	return 0;
}
\end{lstlisting}

\newpage

\subsection{Tutorials}

More complete versions of the program above, including sample datasets and rendering of the optimization result 
as OpenGL scenes are shipped with MRPT\footnote{See the directory \texttt{[MRPT]/samples/srba-examples/srba-tutorials/}, 
or \href{http://mrpt.googlecode.com/svn/trunk/samples/srba-examples/srba-tutorials/}{browse online}.}.
An example screenshot is shown in Fig.~\ref{fig:screenshot.tutorial1}.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{imgs/screenshot_tutorial_range-bearing-3D.pdf} 
\caption{Screenshot for \texttt{tutorial-srba-range-bearing-se3.cpp}.}
\label{fig:screenshot.tutorial1}
\end{figure}

\newpage

\section{Configuring \texttt{RbaEngine<>}}
\label{sect:rba_configs}

\subsection{\texttt{KF2KF\_POSE\_TYPE}: KF-to-KF relative poses}
\label{sec:k2k_types}

Given that the least-squares optimization runs on the linearized neighborhood of the manifold \cite{blanco2010tutorial} 
around the instantaneous solutions, the choice between different parameterizations of SE(3) poses becomes irrelevant. 

XXXX XXXX 

\subsection{\texttt{LM\_TYPE}: Relative landmark parameterizations}
\label{sec:k2f_types}

XXXX XXXX 

\subsection{\texttt{OBS\_TYPE}: Observation types}

XXXX XXXX 


\section{Sensor models}
\label{sect:program_sensors}

XXXX XXXX 


\section{\texttt{RBA\_OPTIONS}: Other options}
\label{sect:rba_options}

XXXX XXXX 


\subsection{\texttt{sensor\_pose\_on\_robot\_t}}


\subsection{\texttt{obs\_noise\_matrix\_t}}


\subsection{\texttt{solver\_t}}



\section{The \texttt{srba-slam} application}
\label{sect:srba_slam_app}

XXXX


\section{Library inner structure}

\subsection{Directory layout}


\subsection{Data structures}


\begin{sidewaysfigure}
\centering
\includegraphics[width=1.0\textwidth]{imgs/srba_data_structures.pdf} 
\caption{Detailed data structures. Refer to the legend for the format of structures and pointers/references.}
\label{fig:detailed.data.structures}
\end{sidewaysfigure}





%% ---------------------------------------------------------------
%%                         BIBLIOGRAPHY
%% ---------------------------------------------------------------
\newpage
\bibliographystyle{plain}
\bibliography{cites}

\end{document}

